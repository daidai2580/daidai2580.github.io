<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Shiro简介</title>
      <link href="/2020/07/01/Shiro%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/07/01/Shiro%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="Shiro简介"><a href="#Shiro简介" class="headerlink" title="Shiro简介"></a>Shiro简介</h2><p><a href="http://shiro.apache.org/" target="_blank" rel="noopener">官网</a><br><img src="https://img-blog.csdnimg.cn/20190404122524221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgxNzYxNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>    Apache Shiro是一款强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API,您可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。</p><h2 id="框架图说明"><a href="#框架图说明" class="headerlink" title="框架图说明"></a>框架图说明</h2><p><a href="http://shiro.apache.org/architecture.html" target="_blank" rel="noopener">官网架构说明</a></p><p><strong>从外部查看Shiro</strong><br><img src="https://img-blog.csdnimg.cn/20190404122844642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgxNzYxNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>        应用代码直接交互的对象是Subject，也就是说Shiro的对外API核心就是Subject</p><table><thead><tr><th>api</th><th>说明</th></tr></thead><tbody><tr><td>Subject</td><td><strong>主体</strong>，代表当前’用户’。这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager；可以把Subject认为是一个门面；SecurityManager才是实际的执行者</td></tr><tr><td>Shiro SecurityManager</td><td><strong>安全管理器</strong>；即所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject；可以看出它是Shiro的核心，它负责与后边介绍的其他组件进行交互，可以把它看成DispatcherServlet前端控制器</td></tr><tr><td>Realm</td><td><strong>域</strong>，Shiro从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。</td></tr><tr><td>## 内部结构框架</td><td></td></tr><tr><td><img src="https://img-blog.csdnimg.cn/20190404123334232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgxNzYxNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></td><td></td></tr><tr><td>组件</td><td>说明</td></tr><tr><td>—————</td><td>————————————————————</td></tr><tr><td>Subject</td><td>主体，可以看到主体可以是任何可以与应用交互的“用户”；</td></tr><tr><td>SecurityManager</td><td>相当于SpringMVC中的DispatcherServlet或者Struts2中的FilterDispatcher；是Shiro的心脏；所有具体的交互都通过SecurityManager进行控制；它管理着所有Subject、且负责进行认证和授权、及会话、缓存的管理。</td></tr><tr><td>Authenticator</td><td>认证器，负责主体认证的，这是一个扩展点，如果用户觉得Shiro默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了；</td></tr><tr><td>Authorizer</td><td>授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；</td></tr><tr><td>Realm</td><td>可以有1个或多个Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC实现，也可以是LDAP实现，或者内存实现等等；由用户提供；注意：Shiro不知道你的用户/权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的Realm；</td></tr><tr><td>SessionManager</td><td>如果写过Servlet就应该知道Session的概念，Session呢需要有人去管理它的生命周期，这个组件就是SessionManager；而Shiro并不仅仅可以用在Web环境，也可以用在如普通的JavaSE环境、EJB等环境；所有呢，Shiro就抽象了一个自己的Session来管理主体与应用之间交互的数据；这样的话，比如我们在Web环境用，刚开始是一台Web服务器；接着又上了台EJB服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到Memcached服务器）；</td></tr><tr><td>SessionDAO</td><td>DAO大家都用过，数据访问对象，用于会话的CRUD，比如我们想把Session保存到数据库，那么可以实现自己的SessionDAO，通过如JDBC写到数据库；比如想把Session放到Memcached中，可以实现自己的Memcached SessionDAO；另外SessionDAO中可以使用Cache进行缓存，以提高性能；</td></tr><tr><td>CacheManager</td><td>缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能</td></tr><tr><td>Cryptography</td><td>密码模块，Shiro提高了一些常见的加密组件用于如密码加密/解密的。</td></tr></tbody></table><h2 id="Shiro中的shiro-ini说明"><a href="#Shiro中的shiro-ini说明" class="headerlink" title="Shiro中的shiro.ini说明"></a>Shiro中的shiro.ini说明</h2><pre><code>shiro.ini放置在classpath路径下shiro会自动查找。ini配置文件中有四大主要配置类main users roles urls</code></pre><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><p>提供了对根对象securityManager及其依赖对象的配置</p><pre><code>#创建对象securityManager=org.apache.shiro.mgt.DefaultSecurityManager</code></pre><p>其构造器必须是public空参构造器，通过反射创建相应的实例。</p><ol><li>对象名=全限定类名 相对于调用public无参构造器创建对象</li><li>对象名.属性名=值 相当于调用setter方法设置常量值</li><li>对象名.属性名=$对象引用 相当于调用setter方法设置对象引用</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>教你如何从零开始搭建一个属于自己的网站</title>
      <link href="/2020/06/02/docker-jenkins/"/>
      <url>/2020/06/02/docker-jenkins/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="服务器项目部署流程"><a href="#服务器项目部署流程" class="headerlink" title="服务器项目部署流程"></a>服务器项目部署流程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该文档为宏狼科技公开的服务器项目部署流程，用于阐述蛋壳技术人员在客户服务器上的所有操作。</p><p>我司使用 Docker 进行服务部署，使用 Docker Compose 编排容器。<br>如果甲方有技术人员，请悉知我司所做的相关操作，并希望能做到不误删服务器环境、不误删数据、不停止甚至删除相关容器等。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>阿里云服务器购买，选择 CentOS 7.2 操作系统。</li><li>网络安全组配置，开放必要的端口 （22、80、443、3306、3307、6379、6380）。</li><li>域名解析，添加所需的 A 记录类型的二级域名解析。</li></ul><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><pre class=" language-sh"><code class="language-sh">$ yum install -y docker</code></pre><h3 id="检查是否安装成功"><a href="#检查是否安装成功" class="headerlink" title="检查是否安装成功"></a>检查是否安装成功</h3><pre class=" language-sh"><code class="language-sh">$ docker -v</code></pre><h2 id="安装-Docker-Compose"><a href="#安装-Docker-Compose" class="headerlink" title="安装 Docker Compose"></a>安装 Docker Compose</h2><pre class=" language-sh"><code class="language-sh">$ pip install docker-compose</code></pre><p>如果没有 pip 工具，则使用官方推荐的方式安装：</p><pre class=" language-sh"><code class="language-sh">$ curl -L https://github.com/docker/compose/releases/download/1.20.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose$ chmod +x /usr/local/bin/docker-compose</code></pre><h3 id="检查是否安装成功-1"><a href="#检查是否安装成功-1" class="headerlink" title="检查是否安装成功"></a>检查是否安装成功</h3><pre class=" language-sh"><code class="language-sh">$ docker-compose -v</code></pre><h2 id="新建-deploy-用户"><a href="#新建-deploy-用户" class="headerlink" title="新建 deploy 用户"></a>新建 deploy 用户</h2><pre class=" language-sh"><code class="language-sh">$ useradd deploy</code></pre><p>修改 deploy 用户密码，统一为 ``。</p><pre class=" language-sh"><code class="language-sh">$ passwd deploy</code></pre><p>添加 sudo 权限，编辑 sudoers：</p><pre class=" language-sh"><code class="language-sh">$ vi /etc/sudoers</code></pre><p>在倒数第十行左右，添加一行配置，允许 deploy 用户 sudo 操作免密码：</p><pre class=" language-sh"><code class="language-sh">## Same thing without a password# %wheel    ALL=(ALL)    NOPASSWD: ALLdeploy ALL=(ALL) NOPASSWD: ALL</code></pre><p>保存退出，切换到 deploy 用户</p><pre class=" language-sh"><code class="language-sh">$ su deploy$ cd ~</code></pre><h2 id="登录-Docker-镜像仓库"><a href="#登录-Docker-镜像仓库" class="headerlink" title="登录 Docker 镜像仓库"></a>登录 Docker 镜像仓库</h2><p>首先开启服务器上的 docker 服务：</p><pre class=" language-sh"><code class="language-sh">$ sudo systemctl start docker.service$ sudo systemctl enable docker.service</code></pre><p>登录阿里云容器镜像仓库：</p><pre class=" language-sh"><code class="language-sh">$ sudo docker login --username=用户名 --password=密码 registry.cn-shenzhen.aliyuncs.comLogin Succeeded</code></pre><h2 id="容器编排"><a href="#容器编排" class="headerlink" title="容器编排"></a>容器编排</h2><h3 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h3><p>在客户服务器上，统一运维目录为 <code>/home/deploy</code>，维护上做到绝对的集中，也避免与服务器原有资源和配置的冲突。</p><p>在此目录创建 docker 目录，用于存放 docker-compose.yml 文件。</p><pre class=" language-sh"><code class="language-sh">$ mkdir -p /home/deploy/docker</code></pre><h3 id="Docker-Compose-配置"><a href="#Docker-Compose-配置" class="headerlink" title="Docker Compose 配置"></a>Docker Compose 配置</h3><p>进入目录，并创建 docker-compose.yml 文件，例如 JAVA 的：</p><pre class=" language-sh"><code class="language-sh">$ cd /home/deploy/docker$ touch docker-compose.yml</code></pre><p><code>vi</code> 编辑 docker-compose.yml 文件，主要分为三部分。</p><h4 id="上层代理"><a href="#上层代理" class="headerlink" title="上层代理"></a>上层代理</h4><p>Nginx 代理服务的配置，支持 SSL 证书的自动创建、续期、配置。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'2'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">nginx-root</span><span class="token punctuation">:</span>    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always    <span class="token key atrule">image</span><span class="token punctuation">:</span> registry.cn<span class="token punctuation">-</span>shenzhen.aliyuncs.com/macrowolf/nginx    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>root    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token datetime number">80:80</span>      <span class="token punctuation">-</span> 443<span class="token punctuation">:</span><span class="token number">443</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> /etc/nginx/conf.d      <span class="token punctuation">-</span> /etc/nginx/vhost.d      <span class="token punctuation">-</span> /usr/share/nginx/html      <span class="token punctuation">-</span> /var/run/docker.sock<span class="token punctuation">:</span>/tmp/docker.sock<span class="token punctuation">:</span>ro      <span class="token punctuation">-</span> /home/deploy/nginx/certs<span class="token punctuation">:</span>/etc/nginx/certs<span class="token punctuation">:</span>ro  <span class="token key atrule">nginx-gen</span><span class="token punctuation">:</span>    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always    <span class="token key atrule">image</span><span class="token punctuation">:</span> registry.cn<span class="token punctuation">-</span>shenzhen.aliyuncs.com/macrowolf/nginx<span class="token punctuation">-</span>gen    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>gen    <span class="token key atrule">volumes_from</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> nginx<span class="token punctuation">-</span>root    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> /var/run/docker.sock<span class="token punctuation">:</span>/tmp/docker.sock<span class="token punctuation">:</span>ro    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">-</span>notify<span class="token punctuation">-</span>sighup nginx<span class="token punctuation">-</span>root <span class="token punctuation">-</span>watch <span class="token punctuation">-</span>wait 5s<span class="token punctuation">:</span>30s /etc/docker<span class="token punctuation">-</span>gen/templates/nginx.tmpl /etc/nginx/conf.d/default.conf  <span class="token key atrule">nginx-certbot</span><span class="token punctuation">:</span>    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always    <span class="token key atrule">image</span><span class="token punctuation">:</span> registry.cn<span class="token punctuation">-</span>shenzhen.aliyuncs.com/macrowolf/nginx<span class="token punctuation">-</span>certbot    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>certbot    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> NGINX_DOCKER_GEN_CONTAINER=nginx<span class="token punctuation">-</span>gen      <span class="token punctuation">-</span> NGINX_PROXY_CONTAINER=nginx<span class="token punctuation">-</span>root    <span class="token key atrule">volumes_from</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> nginx<span class="token punctuation">-</span>root    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> /home/deploy/nginx/certs<span class="token punctuation">:</span>/etc/nginx/certs<span class="token punctuation">:</span>rw      <span class="token punctuation">-</span> /var/run/docker.sock<span class="token punctuation">:</span>/var/run/docker.sock<span class="token punctuation">:</span>ro</code></pre><h4 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h4><p>一般部署数据库，缓存服务等。</p><p>上面列举了 mysql 和 redis 的全环境编排（开发环境、测试环境、生产环境），注意各个服务的 volumes，需要把容器内的持久化数据所在的目录挂载到宿主机上，<strong>请勿删除所挂载的目录，否则会造成数据的丢失</strong>。</p><p>映射的公网端口如下：</p><ul><li>mysql-dev 3306</li><li>mysql-stage 3307</li><li>mysql-prod 3308</li><li>redis-dev 6379</li><li>redis-stage 6380</li><li>redis-prod 6381</li></ul><p>为了安全性，生产环境的端口后期可以不映射到宿主机上。</p><p>如果无法通过宿主机地址和上述端口连接容器服务，请检查防火墙或者阿里云后台的安全组策略。</p><h4 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h4><p>最后一块是项目的部署。</p><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><h3 id="首次启动服务"><a href="#首次启动服务" class="headerlink" title="首次启动服务"></a>首次启动服务</h3><pre class=" language-sh"><code class="language-sh">$ cd ~/docker$ sudo docker-compose up -d</code></pre><h3 id="后续更新项目"><a href="#后续更新项目" class="headerlink" title="后续更新项目"></a>后续更新项目</h3><pre class=" language-sh"><code class="language-sh">$ cd ~/docker$ sudo docker stop javaee-bsd-stage$ sudo docker rm javaee-bsd-stage$ sudo docker rmi registry.cn-shenzhen.aliyuncs.com/macrowolf-project/javaee-bsd-stage$ sudo docker-compose up -d</code></pre><h3 id="下线（如有需要）"><a href="#下线（如有需要）" class="headerlink" title="下线（如有需要）"></a>下线（如有需要）</h3><pre class=" language-sh"><code class="language-sh">$ cd ~/docker$ sudo docker-compose down</code></pre><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2>]]></content>
      
      
      <categories>
          
          <category> 呆呆的小安利 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Docker </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
