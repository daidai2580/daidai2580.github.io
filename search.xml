<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java虚拟机常见内存溢出错误汇总</title>
      <link href="/2020/11/17/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%94%99%E8%AF%AF%E6%B1%87%E6%80%BB/"/>
      <url>/2020/11/17/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%94%99%E8%AF%AF%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="Java虚拟机常见内存溢出错误汇总，Java中常见的坑看了可以少走点弯路"><a href="#Java虚拟机常见内存溢出错误汇总，Java中常见的坑看了可以少走点弯路" class="headerlink" title="Java虚拟机常见内存溢出错误汇总，Java中常见的坑看了可以少走点弯路"></a>Java虚拟机常见内存溢出错误汇总，Java中常见的坑看了可以少走点弯路</h2><h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>从事java开发的小伙伴在平时的开发工作中，应该会遇见各式各样的异常和错误，在实际工作中积累的异常或者错误越多，趟过的坑越多，就会使我们编码更加的健壮，就会本能地避开很多严重的坑。以下介绍几个Java虚拟机常见内存溢出错误。以此警示，避免生产血案。</p><h1 id="二、模拟Java虚拟机常见内存溢出错误"><a href="#二、模拟Java虚拟机常见内存溢出错误" class="headerlink" title="二、模拟Java虚拟机常见内存溢出错误"></a>二、模拟Java虚拟机常见内存溢出错误</h1><p>1、内存溢出之栈溢出错误</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jayway<span class="token punctuation">.</span>oom<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/**  * 栈溢出错误  * 虚拟机参数：-Xms10m -Xmx10m  * 抛出异常：Exception in thread "main" java.lang.StackOverflowError  */</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackOverflowErrorDemo</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">stackOverflowError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">stackOverflowError</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">stackOverflowError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>​    </p><p>2、内存溢出之堆溢出错误</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jayway<span class="token punctuation">.</span>oom<span class="token punctuation">;</span> <span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Random<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/**  * 堆溢出错误  * 虚拟机参数：-Xmx10m -Xms10m * 抛出异常：Exception in thread "main" java.lang.OutOfMemoryError: Java heap space  */</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavaHeapSpaceErrorDemo</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>   String temp <span class="token operator">=</span> <span class="token string">"java"</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//不断地在堆中开辟空间，创建对象，撑爆堆内存</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     temp <span class="token operator">+=</span> temp <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">111111111</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">222222222</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     temp<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>3、内存溢出之GC超过执行限制错误</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jayway<span class="token punctuation">.</span>oom<span class="token punctuation">;</span> <span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span> <span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span> <span class="token operator">/</span><span class="token operator">*</span><span class="token operator">*</span> </code></pre><ul><li><p>GC超过执行限制错误</p></li><li><p>虚拟机参数：-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</p></li><li><ul><li>抛出异常：Exception in thread “main” java.lang.OutOfMemoryError: GC overhead limit exceeded</li></ul></li><li><ul><li>导致原因：GC回收时间过长会抛出OutOfMemoryError，何为过长，即超过98%的cpu时间用来做GC垃圾回收</li></ul></li><li><p>但是回收效果甚微，仅仅只有2%的CPU时间用来用户程序的工作，这种状态是很糟糕的，程序在不断地GC</p></li><li><p>形成恶性循环，CPU的使用率一直是满负荷的，正经活却没有干，这种情况虚拟机只好抛出错误来终止程序的执行</p></li><li><p>不断地Full GC，事倍功微</p></li><li><p>[Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7167K-&gt;7161K(7168K)] 9215K-&gt;9209K(9728K), [Metaspace: 3529K-&gt;3529K(1056768K)], 0.0291829 secs] [Times: user=0.08 sys=0.02, real=0.03 secs]</p></li></ul><pre><code> ```java public class GCOverheadErrorDemo {   public static void main(String[] args) {     int i = 0;     List&lt;String&gt; list = new ArrayList&lt;&gt;();     try {       while (true) {       list.add(String.valueOf(++i).intern());       }     } catch (Throwable e) {       System.out.println(&quot;*****************i:&quot; + i);       e.printStackTrace();       throw e;    }  } }```</code></pre><p>4、内存溢出之直接内存溢出错误</p><pre><code>package com.jayway.oom; import java.nio.ByteBuffer; /** </code></pre><ul><li><p>直接内存溢出错误</p></li><li><p>抛出异常：Exception in thread “main” java.lang.OutOfMemoryError: Direct buffer memory</p></li><li><ul><li>配置虚拟机参数：-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</li></ul></li><li><ul><li>导致原因：通常NIO程序经常使用ByteBuffer来读取或者写入数据，这是一种基于通道（Channel）与缓冲区（Buffer）的IO方式，</li></ul></li><li><p>它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆里面的DirectByteBuffer对象作为这块内存的引用，</p></li><li><p>这样能子一些场景中显著提高性能，因为避免了在Java堆和Native内存中来回复制数据。</p></li><li><p>ByteBuffer.allocate(capability):分配JVM堆内存，数据GC的管辖范围，由于需要拷贝所以速度相对较慢</p></li><li><p>ByteBuffer.allocate(capability):分配OS本地内存，不属于GC管辖范围，由于不需要内存拷贝，所以速度相对较快。</p></li><li><p>但是如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象就不会被回收，此时如果继续分配堆外内存，</p></li><li><p>可能堆外内存已经被耗光了无法继续分配，此时程序就会抛出OutOfMemoryError，直接崩溃。</p><p> */<br> public class DirectBufferMemoryErrorDemo { </p><p>  public static void main(String[] args) { </p><pre><code>//默认JVM配置的最大直接内存是总物理内存的四分之一 long maxDirectMemory = sun.misc.VM.maxDirectMemory() / 1024 / 1024; System.out.println(&quot;配置的maxDirectMemory:&quot; + maxDirectMemory + &quot;MB&quot;); ByteBuffer byteBuffer = ByteBuffer.allocateDirect(6 * 1024 * 1024); </code></pre><p>  } </p><p>}</p></li></ul><p>5、内存溢出之无法创建新的本地线程</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jayway<span class="token punctuation">.</span>oom<span class="token punctuation">;</span> <span class="token operator">/</span><span class="token operator">*</span><span class="token operator">*</span>  <span class="token operator">*</span> 内存溢出之无法创建新的本地线程  <span class="token operator">*</span> 抛出异常：java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>OutOfMemoryError<span class="token operator">:</span> unable to create <span class="token keyword">new</span> <span class="token class-name">native</span> thread </code></pre><ul><li><ul><li>描述：</li></ul></li><li><p>高并发请求服务器时，经常出现java.lang.OutOfMemoryError: unable to create new native thread</p></li><li><p>native thread异常与对应的平台有关</p></li><li><p>导致原因：</p></li><li><p>1、应用程序创建了太多线程了，一个应用进程创建的线程数超过系统承载极限。</p></li><li><p>2、操作系统并不允许你的应用进程创建这么多的线程，linux系统默认允许单个进程可以创建的线程数是1024个</p></li><li><p>解决方法：</p></li><li><p>1、想办法降低应用进程创建的线程数量，</p></li><li><p>2、如果应用程序确实需要这么多线程，超过了linux系统的默认1024个限制，可以通过修改linux服务器配置，提高这个阈值。</p></li></ul><pre><code> ```java  public class UnableCreateNativeThreadErrorDemo {   public static void main(String[] args) {     for (int i = 0; true; i++) {       System.out.println(&quot;***************i:&quot; + i);   //不断得创建新线程，直到超过操作系统允许应用进程创建线程的极限   new Thread(() -&gt; {     try {       Thread.sleep(Integer.MAX_VALUE);     } catch (InterruptedException e) {       e.printStackTrace();     }   }).start();     }  } }```</code></pre><p>6、内存溢出之元空间溢出错误</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>jayway<span class="token punctuation">.</span>oom<span class="token punctuation">;</span> <span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>Enhancer<span class="token punctuation">;</span> <span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>MethodInterceptor<span class="token punctuation">;</span> <span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>MethodProxy<span class="token punctuation">;</span> <span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span> <span class="token operator">/</span><span class="token operator">*</span><span class="token operator">*</span> </code></pre><ul><li><p>元空间溢出错误</p></li><li><p>抛出异常：java.lang.OutOfMemoryError: Metaspace</p></li><li><ul><li>设置虚拟机参数：-XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m</li></ul></li><li><ul><li>描述：Java8及以后的版本使用Metaspace来替代了永久代。metaspace是方法区在HotSpot中的实现，它与持久代最大的区别在于</li></ul></li><li><p>Metaspace并不在虚拟机内存中而是在本地内存中。</p></li><li><p>元空间存储了以下信息：</p></li><li><p>1、虚拟机加载的类信息</p></li><li><p>2、常量池</p></li><li><p>3、静态变量</p></li><li><p>4、即时编译后的代码</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MetaspaceErrorDemo</span> <span class="token punctuation">{</span>   <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OOMTest</span> <span class="token punctuation">{</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">try</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//cglib不断创建类，模拟Metaspace空间溢出，我们不断生成类往元空间中灌，超过元空间大小后就会抛出元空间移除的错误 </span>      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         count<span class="token operator">++</span><span class="token punctuation">;</span>         Enhancer enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>OOMTest<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         enhancer<span class="token punctuation">.</span><span class="token function">setUseCache</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MethodInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token annotation punctuation">@Override</span>          <span class="token keyword">public</span> Object <span class="token function">intercept</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> objects<span class="token punctuation">,</span> MethodProxy methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>             <span class="token keyword">return</span> methodProxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>         <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>     <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"************多少次后发生了异常："</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>       e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre></li></ul><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>以上就是Java虚拟机常见内存溢出错误汇总的详细内容，作为一枚Java程序员真的是太强大了，除了要解决日常的bug还要对付这么多莫名其妙的陷阱，一不小心就掉坑里了。损失的都是自己的头发啊。~~Java中常见的坑还有很多，由于篇幅过长就不一 一展现了。</p>]]></content>
      
      
      <categories>
          
          <category> 呆呆的小随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro简介</title>
      <link href="/2020/11/12/Shiro%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/11/12/Shiro%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="Shiro简介"><a href="#Shiro简介" class="headerlink" title="Shiro简介"></a>Shiro简介</h2><p><a href="http://shiro.apache.org/" target="_blank" rel="noopener">官网</a><br><img src="https://img-blog.csdnimg.cn/20190404122524221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgxNzYxNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>    Apache Shiro是一款强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API,您可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。</p><h2 id="框架图说明"><a href="#框架图说明" class="headerlink" title="框架图说明"></a>框架图说明</h2><p><a href="http://shiro.apache.org/architecture.html" target="_blank" rel="noopener">官网架构说明</a></p><p><strong>从外部查看Shiro</strong><br><img src="https://img-blog.csdnimg.cn/20190404122844642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgxNzYxNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>        应用代码直接交互的对象是Subject，也就是说Shiro的对外API核心就是Subject</p><table><thead><tr><th>api</th><th>说明</th></tr></thead><tbody><tr><td>Subject</td><td><strong>主体</strong>，代表当前’用户’。这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager；可以把Subject认为是一个门面；SecurityManager才是实际的执行者</td></tr><tr><td>Shiro SecurityManager</td><td><strong>安全管理器</strong>；即所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject；可以看出它是Shiro的核心，它负责与后边介绍的其他组件进行交互，可以把它看成DispatcherServlet前端控制器</td></tr><tr><td>Realm</td><td><strong>域</strong>，Shiro从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。</td></tr><tr><td>## 内部结构框架</td><td></td></tr><tr><td><img src="https://img-blog.csdnimg.cn/20190404123334232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgxNzYxNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></td><td></td></tr><tr><td>组件</td><td>说明</td></tr><tr><td>—————</td><td>————————————————————</td></tr><tr><td>Subject</td><td>主体，可以看到主体可以是任何可以与应用交互的“用户”；</td></tr><tr><td>SecurityManager</td><td>相当于SpringMVC中的DispatcherServlet或者Struts2中的FilterDispatcher；是Shiro的心脏；所有具体的交互都通过SecurityManager进行控制；它管理着所有Subject、且负责进行认证和授权、及会话、缓存的管理。</td></tr><tr><td>Authenticator</td><td>认证器，负责主体认证的，这是一个扩展点，如果用户觉得Shiro默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了；</td></tr><tr><td>Authorizer</td><td>授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；</td></tr><tr><td>Realm</td><td>可以有1个或多个Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC实现，也可以是LDAP实现，或者内存实现等等；由用户提供；注意：Shiro不知道你的用户/权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的Realm；</td></tr><tr><td>SessionManager</td><td>如果写过Servlet就应该知道Session的概念，Session呢需要有人去管理它的生命周期，这个组件就是SessionManager；而Shiro并不仅仅可以用在Web环境，也可以用在如普通的JavaSE环境、EJB等环境；所有呢，Shiro就抽象了一个自己的Session来管理主体与应用之间交互的数据；这样的话，比如我们在Web环境用，刚开始是一台Web服务器；接着又上了台EJB服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到Memcached服务器）；</td></tr><tr><td>SessionDAO</td><td>DAO大家都用过，数据访问对象，用于会话的CRUD，比如我们想把Session保存到数据库，那么可以实现自己的SessionDAO，通过如JDBC写到数据库；比如想把Session放到Memcached中，可以实现自己的Memcached SessionDAO；另外SessionDAO中可以使用Cache进行缓存，以提高性能；</td></tr><tr><td>CacheManager</td><td>缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能</td></tr><tr><td>Cryptography</td><td>密码模块，Shiro提高了一些常见的加密组件用于如密码加密/解密的。</td></tr></tbody></table><h2 id="Shiro中的shiro-ini说明"><a href="#Shiro中的shiro-ini说明" class="headerlink" title="Shiro中的shiro.ini说明"></a>Shiro中的shiro.ini说明</h2><pre><code>shiro.ini放置在classpath路径下shiro会自动查找。ini配置文件中有四大主要配置类main users roles urls</code></pre><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><p>提供了对根对象securityManager及其依赖对象的配置</p><pre><code>#创建对象securityManager=org.apache.shiro.mgt.DefaultSecurityManager</code></pre><p>其构造器必须是public空参构造器，通过反射创建相应的实例。</p><ol><li>对象名=全限定类名 相对于调用public无参构造器创建对象</li><li>对象名.属性名=值 相当于调用setter方法设置常量值</li><li>对象名.属性名=$对象引用 相当于调用setter方法设置对象引用</li></ol>]]></content>
      
      
      <categories>
          
          <category> 呆呆的小随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java NIO</title>
      <link href="/2020/11/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%20NIO/"/>
      <url>/2020/11/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%20NIO/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="深入理解Java-NIO"><a href="#深入理解Java-NIO" class="headerlink" title="深入理解Java NIO"></a><a href="https://www.cnblogs.com/geason/p/5774096.html" target="_blank" rel="noopener">深入理解Java NIO</a></h1><p><strong>初识NIO：</strong></p><pre><code>在 JDK 1. 4 中 新 加入 了 NIO( New Input/ Output) 类, 引入了一种基于通道和缓冲区的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆的 DirectByteBuffer 对象作为这块内存的引用进行操作，避免了在 Java 堆和 Native 堆中来回复制数据。NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务。同步的核心就是 Selector，Selector 代替了线程本身轮询 IO 事件，避免了阻塞同时减少了不必要的线程消耗；非阻塞的核心就是通道和缓冲区，当 IO 事件就绪时，可以通过写道缓冲区，保证 IO 的成功，而无需线程阻塞式地等待。</code></pre><p><strong>Buffer：</strong></p><pre><code>为什么说NIO是基于缓冲区的IO方式呢？因为，当一个链接建立完成后，IO的数据未必会马上到达，为了当数据到达时能够正确完成IO操作，在BIO（阻塞IO）中，等待IO的线程必须被阻塞，以全天候地执行IO操作。为了解决这种IO方式低效的问题，引入了缓冲区的概念，当数据到达时，可以预先被写入缓冲区，再由缓冲区交给线程，因此线程无需阻塞地等待IO。</code></pre><p><strong>通道：</strong></p><pre><code>当执行：SocketChannel.write(Buffer)，便将一个 buffer 写到了一个通道中。如果说缓冲区还好理解，通道相对来说就更加抽象。网上博客难免有写不严谨的地方，容易使初学者感到难以理解。引用 Java NIO 中权威的说法：通道是 I/O 传输发生时通过的入口，而缓冲区是这些数 据传输的来源或目标。对于离开缓冲区的传输，您想传递出去的数据被置于一个缓冲区，被传送到通道。对于传回缓冲区的传输，一个通道将数据放置在您所提供的缓冲区中。例如 有一个服务器通道 ServerSocketChannel serverChannel，一个客户端通道 SocketChannel clientChannel；服务器缓冲区：serverBuffer，客户端缓冲区：clientBuffer。当服务器想向客户端发送数据时，需要调用：clientChannel.write(serverBuffer)。当客户端要读时，调用 clientChannel.read(clientBuffer)当客户端想向服务器发送数据时，需要调用：serverChannel.write(clientBuffer)。当服务器要读时，调用 serverChannel.read(serverBuffer)这样，通道和缓冲区的关系似乎更好理解了。在实践中，未必会出现这种双向连接的蠢事（然而这确实存在的，后面的内容还会涉及），但是可以理解为在NIO中：如果想将Data发到目标端，则需要将存储该Data的Buffer，写入到目标端的Channel中，然后再从Channel中读取数据到目标端的Buffer中。</code></pre><p><strong>Selector：</strong></p><p> 通道和缓冲区的机制，使得线程无需阻塞地等待IO事件的就绪，但是总是要有人来监管这些IO事件。这个工作就交给了selector来完成，这就是所谓的同步。</p><pre><code>Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪，这就是所说的轮询。一旦这个方法返回，线程就可以处理这些事件。Selector中注册的感兴趣事件有：</code></pre><ul><li><p>OP_ACCEPT</p></li><li><p>OP_CONNECT </p></li><li><p>OP_READ </p></li><li><p>OP_WRITE</p></li></ul><p><strong>优化：</strong></p><pre><code>一种优化方式是：将Selector进一步分解为Reactor，将不同的感兴趣事件分开，每一个Reactor只负责一种感兴趣的事件。这样做的好处是：1、分离阻塞级别，减少了轮询的时间；2、线程无需遍历set以找到自己感兴趣的事件，因为得到的set中仅包含自己感兴趣的事件。</code></pre><p><strong>NIO和epoll：</strong></p><pre><code>epoll是Linux内核的IO模型。我想一定有人想问，AIO听起来比NIO更加高大上，为什么不使用AIO？AIO其实也有应用，但是有一个问题就是，Linux是不支持AIO的，因此基于AIO的程序运行在Linux上的效率相比NIO反而更低。而Linux是最主要的服务器OS，因此相比AIO，目前NIO的应用更加广泛。说到这里，可能你已经明白了，epoll一定和NIO有着很深的因缘。没错，如果仔细研究epoll的技术内幕，你会发现它确实和NIO非常相似，都是基于“通道”和缓冲区的，也有selector，只是在epoll中，通道实际上是操作系统的“管道”。和NIO不同的是，NIO中，解放了线程，但是需要由selector阻塞式地轮询IO事件的就绪；而epoll中，IO事件就绪后，会自动发送消息，通知selector：“我已经就绪了。”可以认为，Linux的epoll是一种效率更高的NIO。</code></pre><p><strong>NIO轶事：</strong></p><p>一篇有意思的<a href="http://blog.csdn.net/haoel/article/details/2224069" target="_blank" rel="noopener">博客</a>，讲的 Java selector.open() 的时候，会创建一个自己和自己的链接（windows上是tcp，linux上是通道）</p><p>这么做的原因：可以从 Apache Mina 中窥探。在 Mina 中，有如下机制：</p><ol><li><p>Mina框架会创建一个Work对象的线程。</p></li><li><p>Work对象的线程的run()方法会从一个队列中拿出一堆Channel，然后使用Selector.select()方法来侦听是否有数据可以读/写。</p></li><li><p>最关键的是，在select的时候，如果队列有新的Channel加入，那么，Selector.select()会被唤醒，然后重新select最新的Channel集合。</p></li><li><p>要唤醒select方法，只需要调用Selector的wakeup()方法。</p></li></ol><pre><code>而一个阻塞在select上的线程有以下三种方式可以被唤醒：</code></pre><ol><li><p>有数据可读/写，或出现异常。</p></li><li><p>阻塞时间到，即time out。</p></li><li><p>收到一个non-block的信号。可由kill或pthread_kill发出。</p></li></ol><pre><code>首先 2 可以排除，而第三种方式，只在linux中存在。因此，Java NIO为什么要创建一个自己和自己的链接：就是如果想要唤醒select，只需要朝着自己的这个loopback连接发点数据过去，于是，就可以唤醒阻塞在select上的线程了。</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试集合框架</title>
      <link href="/2020/11/12/%E9%9D%A2%E8%AF%95%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
      <url>/2020/11/12/%E9%9D%A2%E8%AF%95%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="1-剖析面试最常见问题之-Java-集合框架"><a href="#1-剖析面试最常见问题之-Java-集合框架" class="headerlink" title="1. 剖析面试最常见问题之 Java 集合框架"></a>1. 剖析面试最常见问题之 Java 集合框架</h1><h2 id="1-1-集合概述"><a href="#1-1-集合概述" class="headerlink" title="1.1. 集合概述"></a>1.1. 集合概述</h2><h3 id="1-1-1-Java-集合概览"><a href="#1-1-1-Java-集合概览" class="headerlink" title="1.1.1. Java 集合概览"></a>1.1.1. Java 集合概览</h3><p>从下图可以看出，在 Java 中除了以 <code>Map</code> 结尾的类之外， 其他类都实现了 <code>Collection</code> 接口。</p><p>并且，以 <code>Map</code> 结尾的类都实现了 <code>Map</code> 接口。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMS5pbWdrci5jb20vdGVtcC9jYTZhNDNlZWQxMWM0ZjdjOWYwYzUxNjIzOTQ1NGJiOC5wbmc?x-oss-process=image/format,png" alt="image" loading="lazy"></p><h3 id="1-1-2-说说-List-Set-Map-三者的区别？"><a href="#1-1-2-说说-List-Set-Map-三者的区别？" class="headerlink" title="1.1.2. 说说 List,Set,Map 三者的区别？"></a>1.1.2. 说说 List,Set,Map 三者的区别？</h3><ul><li><code>List</code>(对付顺序的好帮手)： 存储的元素是有序的、可重复的。</li><li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li><li><code>Map</code>(用 Key 来搜索的专家): 使用键值对（kye-value）存储，类似于数学上的函数 y=f(x)，“x”代表 key，”y”代表 value，Key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul><h3 id="1-1-3-集合框架底层数据结构总结"><a href="#1-1-3-集合框架底层数据结构总结" class="headerlink" title="1.1.3. 集合框架底层数据结构总结"></a>1.1.3. 集合框架底层数据结构总结</h3><p>先来看一下 <code>Collection</code> 接口下面的集合。</p><h4 id="1-1-3-1-List"><a href="#1-1-3-1-List" class="headerlink" title="1.1.3.1. List"></a>1.1.3.1. List</h4><ul><li><code>Arraylist</code>： <code>Object[]</code>数组</li><li><code>Vector</code>：<code>Object[]</code>数组</li><li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li></ul><h4 id="1-1-3-2-Set"><a href="#1-1-3-2-Set" class="headerlink" title="1.1.3.2. Set"></a>1.1.3.2. Set</h4><ul><li><code>HashSet</code>（无序，唯一）: 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li><li><code>LinkedHashSet</code>：<code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li><li><code>TreeSet</code>（有序，唯一）： 红黑树(自平衡的排序二叉树)</li></ul><p>再来看看 <code>Map</code> 接口下面的集合。</p><h4 id="1-1-3-3-Map"><a href="#1-1-3-3-Map" class="headerlink" title="1.1.3.3. Map"></a>1.1.3.3. Map</h4><ul><li><code>HashMap</code>： JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li><li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931" target="_blank" rel="noopener">《LinkedHashMap 源码详细分析（JDK1.8）》</a></li><li><code>Hashtable</code>： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li></ul><h3 id="1-1-4-如何选用集合"><a href="#1-1-4-如何选用集合" class="headerlink" title="1.1.4. 如何选用集合?"></a>1.1.4. 如何选用集合?</h3><p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</p><p>当我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</p><h3 id="1-1-5-为什么要使用集合？"><a href="#1-1-5-为什么要使用集合？" class="headerlink" title="1.1.5. 为什么要使用集合？"></a>1.1.5. 为什么要使用集合？</h3><p>当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端，<br>因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。</p><p>数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。<br>但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据</p><h3 id="1-1-6-Iterator-迭代器"><a href="#1-1-6-Iterator-迭代器" class="headerlink" title="1.1.6. Iterator 迭代器"></a>1.1.6. Iterator 迭代器</h3><h4 id="1-1-6-1-迭代器-Iterator-是什么？"><a href="#1-1-6-1-迭代器-Iterator-是什么？" class="headerlink" title="1.1.6.1. 迭代器 Iterator 是什么？"></a>1.1.6.1. 迭代器 Iterator 是什么？</h4><pre><code>public interface Iterator&lt;E&gt; {    //集合中是否还有元素    boolean hasNext();    //获得集合中的下一个元素    E next();    ......}</code></pre><p><code>Iterator</code> 对象称为迭代器（设计模式的一种），迭代器可以对集合进行遍历，但每一个集合内部的数据结构可能是不尽相同的，所以每一个集合存和取都很可能是不一样的，虽然我们可以人为地在每一个类中定义 <code>hasNext()</code> 和 <code>next()</code> 方法，但这样做会让整个集合体系过于臃肿。于是就有了迭代器。</p><p>迭代器是将这样的方法抽取出接口，然后在每个类的内部，定义自己迭代方式，这样做就规定了整个集合体系的遍历方式都是 <code>hasNext()</code>和<code>next()</code>方法，使用者不用管怎么实现的，会用即可。迭代器的定义为：提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。</p><h4 id="1-1-6-2-迭代器-Iterator-有啥用？"><a href="#1-1-6-2-迭代器-Iterator-有啥用？" class="headerlink" title="1.1.6.2. 迭代器 Iterator 有啥用？"></a>1.1.6.2. 迭代器 Iterator 有啥用？</h4><p><code>Iterator</code> 主要是用来遍历集合用的，它的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 <code>ConcurrentModificationException</code> 异常。</p><h4 id="1-1-6-3-如何使用？"><a href="#1-1-6-3-如何使用？" class="headerlink" title="1.1.6.3. 如何使用？"></a>1.1.6.3. 如何使用？</h4><p>我们通过使用迭代器来遍历 <code>HashMap</code>，演示一下 迭代器 Iterator 的使用。</p><pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Java"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"C++"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"PHP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Iterator<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> String<span class="token operator">>></span> iterator <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="1-1-7-有哪些集合是线程不安全的？怎么解决呢？"><a href="#1-1-7-有哪些集合是线程不安全的？怎么解决呢？" class="headerlink" title="1.1.7. 有哪些集合是线程不安全的？怎么解决呢？"></a>1.1.7. 有哪些集合是线程不安全的？怎么解决呢？</h3><p>我们常用的 <code>Arraylist</code> ,<code>LinkedList</code>,<code>Hashmap</code>,<code>HashSet</code>,<code>TreeSet</code>,<code>TreeMap</code>，<code>PriorityQueue</code> 都不是线程安全的。解决办法很简单，可以使用线程安全的集合来代替。</p><p>如果你要使用线程安全的集合的话， <code>java.util.concurrent</code> 包中提供了很多并发容器供你使用：</p><ol><li><code>ConcurrentHashMap</code>: 可以看作是线程安全的 <code>HashMap</code></li><li><code>CopyOnWriteArrayList</code>:可以看作是线程安全的 <code>ArrayList</code>，在读多写少的场合性能非常好，远远好于 <code>Vector</code>.</li><li><code>ConcurrentLinkedQueue</code>:高效的并发队列，使用链表实现。可以看做一个线程安全的 <code>LinkedList</code>，这是一个非阻塞队列。</li><li><code>BlockingQueue</code>: 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</li><li><code>ConcurrentSkipListMap</code> :跳表的实现。这是一个<code>Map</code>，使用跳表的数据结构进行快速查找。</li></ol><h2 id="1-2-Collection-子接口之-List"><a href="#1-2-Collection-子接口之-List" class="headerlink" title="1.2. Collection 子接口之 List"></a>1.2. Collection 子接口之 List</h2><h3 id="1-2-1-Arraylist-和-Vector-的区别"><a href="#1-2-1-Arraylist-和-Vector-的区别" class="headerlink" title="1.2.1. Arraylist 和 Vector 的区别?"></a>1.2.1. Arraylist 和 Vector 的区别?</h3><ol><li>ArrayList 是 List 的主要实现类，底层使用 Object[ ]存储，适用于频繁的查找工作，线程不安全 ；</li><li>Vector 是 List 的古老实现类，底层使用 Object[ ]存储，线程安全的。</li></ol><h3 id="1-2-2-Arraylist-与-LinkedList-区别"><a href="#1-2-2-Arraylist-与-LinkedList-区别" class="headerlink" title="1.2.2. Arraylist 与 LinkedList 区别?"></a>1.2.2. Arraylist 与 LinkedList 区别?</h3><ol><li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li><li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></li><li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>内存空间占用：</strong> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ol><h4 id="1-2-2-1-补充内容-双向链表和双向循环链表"><a href="#1-2-2-1-补充内容-双向链表和双向循环链表" class="headerlink" title="1.2.2.1. 补充内容:双向链表和双向循环链表"></a>1.2.2.1. 补充内容:双向链表和双向循环链表</h4><p><strong>双向链表：</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p><blockquote><p>另外推荐一篇把双向链表讲清楚的文章：<a href="https://juejin.im/post/5b5d1a9af265da0f47352f14" target="_blank" rel="noopener">https://juejin.im/post/5b5d1a9af265da0f47352f14</a></p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9teS1ibG9nLXRvLXVzZS5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vMjAxOS02LyVFNSU4RiU4QyVFNSU5MCU5MSVFOSU5MyVCRSVFOCVBMSVBOC5wbmc?x-oss-process=image/format,png" alt="双向链表" loading="lazy"></p><p><strong>双向循环链表：</strong> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9teS1ibG9nLXRvLXVzZS5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vMjAxOS02LyVFNSU4RiU4QyVFNSU5MCU5MSVFNSVCRSVBQSVFNyU4RSVBRiVFOSU5MyVCRSVFOCVBMSVBOC5wbmc?x-oss-process=image/format,png" alt="双向循环链表" loading="lazy"></p><h4 id="1-2-2-2-补充内容-RandomAccess-接口"><a href="#1-2-2-2-补充内容-RandomAccess-接口" class="headerlink" title="1.2.2.2. 补充内容:RandomAccess 接口"></a>1.2.2.2. 补充内容:RandomAccess 接口</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RandomAccess</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>查看源码我们发现实际上 <code>RandomAccess</code> 接口中什么都没有定义。所以，在我看来 <code>RandomAccess</code> 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p><p>在 <code>binarySearch（)</code> 方法中，它要判断传入的 list 是否 <code>RamdomAccess</code> 的实例，如果是，调用<code>indexedBinarySearch()</code>方法，如果不是，那么调用<code>iteratorBinarySearch()</code>方法</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span>    <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">>></span> list<span class="token punctuation">,</span> T key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token keyword">instanceof</span> <span class="token class-name">RandomAccess</span> <span class="token operator">||</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>BINARYSEARCH_THRESHOLD<span class="token punctuation">)</span>            <span class="token keyword">return</span> Collections<span class="token punctuation">.</span><span class="token function">indexedBinarySearch</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> Collections<span class="token punctuation">.</span><span class="token function">iteratorBinarySearch</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。为什么呢？我觉得还是和底层数据结构有关！<code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。，<code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的！</p><h3 id="1-2-3-说一说-ArrayList-的扩容机制吧"><a href="#1-2-3-说一说-ArrayList-的扩容机制吧" class="headerlink" title="1.2.3. 说一说 ArrayList 的扩容机制吧"></a>1.2.3. 说一说 ArrayList 的扩容机制吧</h3><p>详见笔主的这篇文章:<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md" target="_blank" rel="noopener">通过源码一步一步分析 ArrayList 扩容机制</a></p><h2 id="1-3-Collection-子接口之-Set"><a href="#1-3-Collection-子接口之-Set" class="headerlink" title="1.3. Collection 子接口之 Set"></a>1.3. Collection 子接口之 Set</h2><h3 id="1-3-1-comparable-和-Comparator-的区别"><a href="#1-3-1-comparable-和-Comparator-的区别" class="headerlink" title="1.3.1. comparable 和 Comparator 的区别"></a>1.3.1. comparable 和 Comparator 的区别</h3><ul><li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code>.</p><h4 id="1-3-1-1-Comparator-定制排序"><a href="#1-3-1-1-Comparator-定制排序" class="headerlink" title="1.3.1.1. Comparator 定制排序"></a>1.3.1.1. Comparator 定制排序</h4><pre class=" language-java"><code class="language-java">        ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> arrayList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"原始数组:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// void reverse(List list)：反转</span>        Collections<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Collections.reverse(arrayList):"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// void sort(List list),按自然排序的升序排序</span>        Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Collections.sort(arrayList):"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 定制排序的用法</span>        Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Integer o1<span class="token punctuation">,</span> Integer o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> o2<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>o1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"定制排序后："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Output:</p><pre class=" language-java"><code class="language-java">原始数组<span class="token operator">:</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">]</span>Collections<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>定制排序后：<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">]</span></code></pre><h4 id="1-3-1-2-重写-compareTo-方法实现按年龄来排序"><a href="#1-3-1-2-重写-compareTo-方法实现按年龄来排序" class="headerlink" title="1.3.1.2. 重写 compareTo 方法实现按年龄来排序"></a>1.3.1.2. 重写 compareTo 方法实现按年龄来排序</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span><span class="token comment" spellcheck="true">// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span><span class="token comment" spellcheck="true">// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span><span class="token keyword">public</span>  <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Person<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * T重写compareTo方法实现按年龄来排序     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>Person o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">></span> o<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">&lt;</span> o<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>​    </p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeMap<span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> String<span class="token operator">></span> pdata <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pdata<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"zhangsan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pdata<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"lisi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pdata<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"王五"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"wangwu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pdata<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"小红"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"xiaohong"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 得到key的值的同时得到key所对应的值</span>        Set<span class="token operator">&lt;</span>Person<span class="token operator">></span> keys <span class="token operator">=</span> pdata<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Person key <span class="token operator">:</span> keys<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> key<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>Output：</p><pre><code>5-小红10-王五20-李四30-张三</code></pre><h3 id="1-3-2-无序性和不可重复性的含义是什么"><a href="#1-3-2-无序性和不可重复性的含义是什么" class="headerlink" title="1.3.2. 无序性和不可重复性的含义是什么"></a>1.3.2. 无序性和不可重复性的含义是什么</h3><p>1、什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p><p>2、什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</p><h3 id="1-3-3-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#1-3-3-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="1.3.3. 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>1.3.3. 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><p>HashSet 是 Set 接口的主要实现类 ，HashSet 的底层是 HashMap，线程不安全的，可以存储 null 值；</p><p>LinkedHashSet 是 HashSet 的子类，能够按照添加的顺序遍历；</p><p>TreeSet 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。</p><h2 id="1-4-Map-接口"><a href="#1-4-Map-接口" class="headerlink" title="1.4. Map 接口"></a>1.4. Map 接口</h2><h3 id="1-4-1-HashMap-和-Hashtable-的区别"><a href="#1-4-1-HashMap-和-Hashtable-的区别" class="headerlink" title="1.4.1. HashMap 和 Hashtable 的区别"></a>1.4.1. HashMap 和 Hashtable 的区别</h3><ol><li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的,因为 HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li><li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li><li><strong>对 Null key 和 Null value 的支持：</strong> HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol><p><strong>HashMap 中带有初始容量的构造函数：</strong></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span>                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>            initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> Float<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span>                                               loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>下面这个方法保证了 HashMap 总是使用 2 的幂作为哈希表的大小。</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * Returns a power of two size for the given target capacity.     */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">8</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_CAPACITY <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="1-4-2-HashMap-和-HashSet-区别"><a href="#1-4-2-HashMap-和-HashSet-区别" class="headerlink" title="1.4.2. HashMap 和 HashSet 区别"></a>1.4.2. HashMap 和 HashSet 区别</h3><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p><p>HashMap</p><p>HashSet</p><p>实现了 Map 接口</p><p>实现 Set 接口</p><p>存储键值对</p><p>仅存储对象</p><p>调用 <code>put()</code>向 map 中添加元素</p><p>调用 <code>add()</code>方法向 Set 中添加元素</p><p>HashMap 使用键（Key）计算 Hashcode</p><p>HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相同，所以 equals()方法用来判断对象的相等性，</p><h3 id="1-4-3-HashMap-和-TreeMap-区别"><a href="#1-4-3-HashMap-和-TreeMap-区别" class="headerlink" title="1.4.3. HashMap 和 TreeMap 区别"></a>1.4.3. HashMap 和 TreeMap 区别</h3><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMS5pbWdrci5jb20vdGVtcC9lYzQ3ZDBhMDFjYjA0ODIzYjkwMTgxZmFlYjc4YWVjYi5wbmc?x-oss-process=image/format,png" alt="image" loading="lazy"></p><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p><p>实现<code>SortMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author shuang.kou * @createTime 2020年06月15日 17:02:00 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>Integer age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Integer <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>​    </p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeMap<span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> String<span class="token operator">></span> treeMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Person<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Person person1<span class="token punctuation">,</span> Person person2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> num <span class="token operator">=</span> person1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> person2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> Integer<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"person1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"person2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"person3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"person4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        treeMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>personStringEntry <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>personStringEntry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出:</p><pre><code>person1person4person2person3</code></pre><p>可以看出，<code>TreeMap</code> 中的元素已经是按照 <code>Person</code> 的 age 字段的升序来排列了。</p><p>上面，我们是通过传入匿名内部类的方式实现的，你可以将代码替换成 Lambda 表达式实现的方式：</p><pre class=" language-java"><code class="language-java">TreeMap<span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> String<span class="token operator">></span> treeMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span>person1<span class="token punctuation">,</span> person2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> num <span class="token operator">=</span> person1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> person2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> Integer<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>综上，相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p><h3 id="1-4-4-HashSet-如何检查重复"><a href="#1-4-4-HashSet-如何检查重复" class="headerlink" title="1.4.4. HashSet 如何检查重复"></a>1.4.4. HashSet 如何检查重复</h3><p>当你把对象加入<code>HashSet</code>时，HashSet 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用<code>equals()</code>方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。（摘自我的 Java 启蒙书《Head fist java》第二版）</p><p><strong>hashCode()与 equals()的相关规定：</strong></p><ol><li>如果两个对象相等，则 hashcode 一定也是相同的</li><li>两个对象相等,对两个 equals 方法返回 true</li><li>两个对象有相同的 hashcode 值，它们也不一定是相等的</li><li>综上，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><p><strong>==与 equals 的区别</strong></p><p>对于基本类型来说，== 比较的是值是否相等；</p><p>对于引用类型来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）；</p><p>对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。</p><h3 id="1-4-5-HashMap-的底层实现"><a href="#1-4-5-HashMap-的底层实现" class="headerlink" title="1.4.5. HashMap 的底层实现"></a>1.4.5. HashMap 的底层实现</h3><h4 id="1-4-5-1-JDK1-8-之前"><a href="#1-4-5-1-JDK1-8-之前" class="headerlink" title="1.4.5.1. JDK1.8 之前"></a>1.4.5.1. JDK1.8 之前</h4><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p><p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p><p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p><p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> h<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// key.hashCode()：返回散列值也就是hashcode</span>      <span class="token comment" spellcheck="true">// ^ ：按位异或</span>      <span class="token comment" spellcheck="true">// >>>:无符号右移，忽略符号位，空位都以0补齐</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// This function ensures that hashCodes that differ only by</span>    <span class="token comment" spellcheck="true">// constant multiples at each bit position have a bounded</span>    <span class="token comment" spellcheck="true">// number of collisions (approximately 8 at default load factor).</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMS5pbWdrci5jb20vdGVtcC83N2M5NWViNzMzMjg0ZGJkOGNlNGU4NWM5Y2I2YjA0Mi5wbmc?x-oss-process=image/format,png" alt="jdk1.8之前的内部结构-HashMap" loading="lazy"></p><h4 id="1-4-5-2-JDK1-8-之后"><a href="#1-4-5-2-JDK1-8-之后" class="headerlink" title="1.4.5.2. JDK1.8 之后"></a>1.4.5.2. JDK1.8 之后</h4><p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMS5pbWdrci5jb20vdGVtcC8xOWY5N2MyYWQ1M2I0ZmYyOTQ4ZWU0YjQ3OTJlYmUxYS5wbmc?x-oss-process=image/format,png" alt="jdk1.8之后的内部结构-HashMap" loading="lazy"></p><blockquote><p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p></blockquote><h3 id="1-4-6-HashMap-的长度为什么是-2-的幂次方"><a href="#1-4-6-HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="1.4.6. HashMap 的长度为什么是 2 的幂次方"></a>1.4.6. HashMap 的长度为什么是 2 的幂次方</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p><p><strong>这个算法应该如何设计呢？</strong></p><p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</strong></p><h3 id="1-4-7-HashMap-多线程操作导致死循环问题"><a href="#1-4-7-HashMap-多线程操作导致死循环问题" class="headerlink" title="1.4.7. HashMap 多线程操作导致死循环问题"></a>1.4.7. HashMap 多线程操作导致死循环问题</h3><p>主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p><p>详情请查看：<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9606.html</a></p><h3 id="1-4-8-HashMap-有哪几种常见的遍历方式"><a href="#1-4-8-HashMap-有哪几种常见的遍历方式" class="headerlink" title="1.4.8. HashMap 有哪几种常见的遍历方式?"></a>1.4.8. HashMap 有哪几种常见的遍历方式?</h3><p><a href="https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow" target="_blank" rel="noopener">HashMap 的 7 种遍历方式与性能分析！</a></p><h3 id="1-4-9-ConcurrentHashMap-和-Hashtable-的区别"><a href="#1-4-9-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="1.4.9. ConcurrentHashMap 和 Hashtable 的区别"></a>1.4.9. ConcurrentHashMap 和 Hashtable 的区别</h3><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构：</strong> JDK1.7 的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><p><strong>两者的对比图：</strong></p><p><strong>HashTable:</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9teS1ibG9nLXRvLXVzZS5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vMjAxOS02L0hhc2hUYWJsZSVFNSU4NSVBOCVFOCVBMSVBOCVFOSU5NCU4MS5wbmc?x-oss-process=image/format,png" alt="HashTable全表锁" loading="lazy"></p><p><a href="http://www.cnblogs.com/chengxiao/p/6842045.html&gt;" target="_blank" rel="noopener">http://www.cnblogs.com/chengxiao/p/6842045.html&gt;</a></p><p><strong>JDK1.7 的 ConcurrentHashMap：</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9teS1ibG9nLXRvLXVzZS5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vMjAxOS02L0NvbmN1cnJlbnRIYXNoTWFwJUU1JTg4JTg2JUU2JUFFJUI1JUU5JTk0JTgxLmpwZw?x-oss-process=image/format,png" alt="JDK1.7的ConcurrentHashMap" loading="lazy"></p><p><a href="http://www.cnblogs.com/chengxiao/p/6842045.html&gt;" target="_blank" rel="noopener">http://www.cnblogs.com/chengxiao/p/6842045.html&gt;</a></p><p><strong>JDK1.8 的 ConcurrentHashMap：</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMS5pbWdrci5jb20vdGVtcC8yNmZjYTc1Y2NjODc0YzhmYmJlYjRmYmNkNGRlYzRhYS5wbmc?x-oss-process=image/format,png" alt="JDK1.8 的 ConcurrentHashMap" loading="lazy"></p><p>JDK1.8 的 <code>ConcurrentHashMap</code> 不在是 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。不过，Node 只能用于链表的情况，红黑树的情况需要使用 <strong><code>TreeNode</code></strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p><h3 id="1-4-10-ConcurrentHashMap-线程安全的具体实现方式-底层具体实现"><a href="#1-4-10-ConcurrentHashMap-线程安全的具体实现方式-底层具体实现" class="headerlink" title="1.4.10. ConcurrentHashMap 线程安全的具体实现方式/底层具体实现"></a>1.4.10. ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</h3><h4 id="1-4-10-1-JDK1-7（上面有示意图）"><a href="#1-4-10-1-JDK1-7（上面有示意图）" class="headerlink" title="1.4.10.1. JDK1.7（上面有示意图）"></a>1.4.10.1. JDK1.7（上面有示意图）</h4><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p><strong>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成</strong>。</p><p>Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Segment</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和 HashMap 类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 的锁。</p><h4 id="1-4-10-2-JDK1-8-（上面有示意图）"><a href="#1-4-10-2-JDK1-8-（上面有示意图）" class="headerlink" title="1.4.10.2. JDK1.8 （上面有示意图）"></a>1.4.10.2. JDK1.8 （上面有示意图）</h4><p>ConcurrentHashMap 取消了 Segment 分段锁，采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）</p><p>synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p><h2 id="1-5-Collections-工具类"><a href="#1-5-Collections-工具类" class="headerlink" title="1.5. Collections 工具类"></a>1.5. Collections 工具类</h2><p>Collections 工具类常用方法:</p><ol><li>排序</li><li>查找,替换操作</li><li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li></ol><h3 id="1-5-1-排序操作"><a href="#1-5-1-排序操作" class="headerlink" title="1.5.1. 排序操作"></a>1.5.1. 排序操作</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span>List list<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//反转</span><span class="token keyword">void</span> <span class="token function">shuffle</span><span class="token punctuation">(</span>List list<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//随机排序</span><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>List list<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//按自然排序的升序排序</span><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>List list<span class="token punctuation">,</span> Comparator c<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//定制排序，由Comparator控制排序逻辑</span><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>List list<span class="token punctuation">,</span> <span class="token keyword">int</span> i <span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//交换两个索引位置的元素</span><span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span>List list<span class="token punctuation">,</span> <span class="token keyword">int</span> distance<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span></code></pre><h3 id="1-5-2-查找-替换操作"><a href="#1-5-2-查找-替换操作" class="headerlink" title="1.5.2. 查找,替换操作"></a>1.5.2. 查找,替换操作</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>List list<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//对List进行二分查找，返回索引，注意List必须是有序的</span><span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span>Collection coll<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span><span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span>Collection coll<span class="token punctuation">,</span> Comparator c<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span><span class="token keyword">void</span> <span class="token function">fill</span><span class="token punctuation">(</span>List list<span class="token punctuation">,</span> Object obj<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//用指定的元素代替指定list中的所有元素。</span><span class="token keyword">int</span> <span class="token function">frequency</span><span class="token punctuation">(</span>Collection c<span class="token punctuation">,</span> Object o<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//统计元素出现次数</span><span class="token keyword">int</span> <span class="token function">indexOfSubList</span><span class="token punctuation">(</span>List list<span class="token punctuation">,</span> List target<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).</span><span class="token keyword">boolean</span> <span class="token function">replaceAll</span><span class="token punctuation">(</span>List list<span class="token punctuation">,</span> Object oldVal<span class="token punctuation">,</span> Object newVal<span class="token punctuation">)</span><span class="token punctuation">,</span> 用新元素替换旧元素</code></pre><h3 id="1-5-3-同步控制"><a href="#1-5-3-同步控制" class="headerlink" title="1.5.3. 同步控制"></a>1.5.3. 同步控制</h3><p><code>Collections</code> 提供了多个<code>synchronizedXxx()</code>方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p><p>我们知道 <code>HashSet</code>，<code>TreeSet</code>，<code>ArrayList</code>,<code>LinkedList</code>,<code>HashMap</code>,<code>TreeMap</code> 都是线程不安全的。<code>Collections</code> 提供了多个静态方法可以把他们包装成线程同步的集合。</p><p><strong>最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。</strong></p><p>方法如下：</p><pre class=" language-java"><code class="language-java"><span class="token function">synchronizedCollection</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span>T<span class="token operator">></span>  c<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//返回指定 collection 支持的同步（线程安全的）collection。</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>T<span class="token operator">></span> list<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//返回指定列表支持的同步（线程安全的）List。</span><span class="token function">synchronizedMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//返回由指定映射支持的同步（线程安全的）Map。</span><span class="token function">synchronizedSet</span><span class="token punctuation">(</span>Set<span class="token operator">&lt;</span>T<span class="token operator">></span> s<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//返回指定 set 支持的同步（线程安全的）set。</span></code></pre><h2 id="1-6-其他重要问题"><a href="#1-6-其他重要问题" class="headerlink" title="1.6. 其他重要问题"></a>1.6. 其他重要问题</h2><h3 id="1-6-1-什么是快速失败-fail-fast-？"><a href="#1-6-1-什么是快速失败-fail-fast-？" class="headerlink" title="1.6.1. 什么是快速失败(fail-fast)？"></a>1.6.1. 什么是快速失败(fail-fast)？</h3><p><strong>快速失败(fail-fast)</strong> 是 Java 集合的一种错误检测机制。<strong>在使用迭代器对集合进行遍历的时候，我们在多线程下操作非安全失败(fail-safe)的集合类可能就会触发 fail-fast 机制，导致抛出 <code>ConcurrentModificationException</code> 异常。 另外，在单线程下，如果在遍历过程中对集合对象的内容进行了修改的话也会触发 fail-fast 机制。</strong></p><blockquote><p>注：增强 for 循环也是借助迭代器进行遍历。</p></blockquote><p>举个例子：多线程下，如果线程 1 正在对集合进行遍历，此时线程 2 对集合进行修改（增加、删除、修改），或者线程 1 在遍历过程中对集合进行修改，都会导致线程 1 抛出 <code>ConcurrentModificationException</code> 异常。</p><p><strong>为什么呢？</strong></p><p>每当迭代器使用 <code>hashNext()</code>/<code>next()</code>遍历下一个元素之前，都会检测 <code>modCount</code> 变量是否为 <code>expectedModCount</code> 值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p>如果我们在集合被遍历期间对其进行修改的话，就会改变 <code>modCount</code> 的值，进而导致 <code>modCount != expectedModCount</code> ，进而抛出 <code>ConcurrentModificationException</code> 异常。</p><blockquote><p>注：通过 <code>Iterator</code> 的方法修改集合的话会修改到 <code>expectedModCount</code> 的值，所以不会抛出异常。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>好吧！相信大家已经搞懂了快速失败(fail-fast)机制以及它的原理。</p><p>我们再来趁热打铁，看一个阿里巴巴手册相关的规定：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9hZDI4ZTNiYS1lNDE5LTQ3MjQtODY5Yy03Mzg3OWU2MDRkYTEucG5n?x-oss-process=image/format,png" alt="" loading="lazy"></p><p>有了前面讲的基础，我们应该知道：使用 <code>Iterator</code> 提供的 <code>remove</code> 方法，可以修改到 <code>expectedModCount</code> 的值。所以，才不会再抛出<code>ConcurrentModificationException</code> 异常。</p><h3 id="1-6-2-什么是安全失败-fail-safe-呢？"><a href="#1-6-2-什么是安全失败-fail-safe-呢？" class="headerlink" title="1.6.2. 什么是安全失败(fail-safe)呢？"></a>1.6.2. 什么是安全失败(fail-safe)呢？</h3><p>明白了快速失败(fail-fast)之后，安全失败(fail-safe)我们就很好理解了。</p><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。所以，在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 <code>ConcurrentModificationException</code> 异常。</p><h3 id="1-6-3-Arrays-asList-避坑指南"><a href="#1-6-3-Arrays-asList-避坑指南" class="headerlink" title="1.6.3. Arrays.asList()避坑指南"></a>1.6.3. Arrays.asList()避坑指南</h3><p>最近使用<code>Arrays.asList()</code>遇到了一些坑，然后在网上看到这篇文章：<a href="http://javadevnotes.com/java-array-to-list-examples" target="_blank" rel="noopener">Java Array to List Examples</a> 感觉挺不错的，但是还不是特别全面。所以，自己对于这块小知识点进行了简单的总结。</p><h4 id="1-6-3-1-简介"><a href="#1-6-3-1-简介" class="headerlink" title="1.6.3.1. 简介"></a>1.6.3.1. 简介</h4><p><code>Arrays.asList()</code>在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个 List 集合。</p><pre class=" language-java"><code class="language-java">String<span class="token punctuation">[</span><span class="token punctuation">]</span> myArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span> <span class="token punctuation">}</span>；List<span class="token operator">&lt;</span>String<span class="token operator">></span> myList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>myArray<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//上面两个语句等价于下面一条语句</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> myList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Apple"</span><span class="token punctuation">,</span><span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>JDK 源码对于这个方法的说明：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，与           Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">asList</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="1-6-3-2-《阿里巴巴-Java-开发手册》对其的描述"><a href="#1-6-3-2-《阿里巴巴-Java-开发手册》对其的描述" class="headerlink" title="1.6.3.2. 《阿里巴巴 Java 开发手册》对其的描述"></a>1.6.3.2. 《阿里巴巴 Java 开发手册》对其的描述</h4><p><code>Arrays.asList()</code>将数组转换为集合后,底层其实还是数组，《阿里巴巴 Java 开发手册》对于这个方法有如下描述：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-QyCTYWHB-1593343041094)(<a href="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B-Arrays.asList%28%29%5D%E6%96%B9%E6%B3%95.png" target="_blank" rel="noopener">https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/阿里巴巴Java开发手-Arrays.asList()]方法.png</a>)</p><h4 id="1-6-3-3-使用时的注意事项总结"><a href="#1-6-3-3-使用时的注意事项总结" class="headerlink" title="1.6.3.3. 使用时的注意事项总结"></a>1.6.3.3. 使用时的注意事项总结</h4><p><strong>传递的数组必须是对象数组，而不是基本类型。</strong></p><p><code>Arrays.asList()</code>是泛型方法，传入的对象必须是对象数组。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> myArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>List myList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>myArray<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>myList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>myList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//数组地址值</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>myList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//报错：ArrayIndexOutOfBoundsException</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> myList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1</span></code></pre><p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时 List 的唯一元素就是这个数组，这也就解释了上面的代码。</p><p>我们使用包装类型数组就可以解决这个问题。</p><pre class=" language-java"><code class="language-java">Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> myArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><strong>使用集合的修改方法:<code>add()</code>、<code>remove()</code>、<code>clear()</code>会抛出异常。</strong></p><pre class=" language-java"><code class="language-java">List myList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//运行时报错：UnsupportedOperationException</span>myList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//运行时报错：UnsupportedOperationException</span>myList<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//运行时报错：UnsupportedOperationException</span></code></pre><p><code>Arrays.asList()</code> 方法返回的并不是 <code>java.util.ArrayList</code> ，而是 <code>java.util.Arrays</code> 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p><pre class=" language-java"><code class="language-java">List myList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>myList<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//class java.util.Arrays$ArrayList</span></code></pre><p>下图是<code>java.util.Arrays$ArrayList</code>的简易源码，我们可以看到这个类重写的方法有哪些。</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token operator">&lt;</span>E<span class="token operator">></span>        <span class="token keyword">implements</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable    <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> E <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">forEach</span><span class="token punctuation">(</span>Consumer<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> E<span class="token operator">></span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">replaceAll</span><span class="token punctuation">(</span>UnaryOperator<span class="token operator">&lt;</span>E<span class="token operator">></span> operator<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> E<span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>我们再看一下<code>java.util.AbstractList</code>的<code>remove()</code>方法，这样我们就明白为啥会抛出<code>UnsupportedOperationException</code>。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>githup项目推荐</title>
      <link href="/2020/11/12/githup%E9%A1%B9%E7%9B%AE%E6%8E%A8%E8%8D%90/"/>
      <url>/2020/11/12/githup%E9%A1%B9%E7%9B%AE%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ol><li><strong><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">JavaGuide</a></strong> :【Java学习 面试指南】 一份涵盖大部分Java程序员所需要掌握的核心知识。</li><li><strong><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">CS-Notes</a></strong> ：技术面试必备基础知识、Leetcode 题解、后端面试、Java 面试、春招、秋招、操作系统、计算机网络、系统设计。</li><li><strong><a href="https://github.com/doocs/advanced-java" target="_blank" rel="noopener">advanced-java</a></strong> :互联网 Java 工程师进阶知识完全扫盲：涵盖高并发、分布式、高可用、微服务、海量数据处理等领域知识。</li><li><strong><a href="https://github.com/xingshaocheng/architect-awesome" target="_blank" rel="noopener">architect-awesome</a></strong> ：后端架构师技术图谱。</li><li><strong><a href="https://github.com/hollischuang/toBeTopJavaer/issues" target="_blank" rel="noopener">toBeTopJavaer</a></strong> ：Java工程师成神之路 。</li><li><strong><a href="https://github.com/eugenp/tutorials" target="_blank" rel="noopener">tutorials</a></strong>：该项目是一系列小而专注的教程 - 每个教程都涵盖 Java 生态系统中单一且定义明确的开发领域。 当然，它们的重点是 Spring Framework - Spring，Spring Boot 和 Spring Securiyt。 除了 Spring 之外，还有以下技术：核心 Java，Jackson，HttpClient，Guava。</li><li><strong><a href="https://github.com/crossoverJie/JCSprout" target="_blank" rel="noopener">JCSprout</a></strong> :处于萌芽阶段的Java核心知识库。</li><li><strong><a href="https://github.com/AobingJava/JavaFamily" target="_blank" rel="noopener">JavaFamily</a></strong> ：【互联网一线大厂面试 学习指南】进阶知识完全扫盲。</li><li><strong><a href="https://github.com/javagrowing/JGrowing" target="_blank" rel="noopener">JGrowing</a></strong> ：Java is Growing up but not only Java。Java成长路线，但学到不仅仅是Java。</li></ol><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><ol><li><strong><a href="https://github.com/spring-projects/spring-boot" target="_blank" rel="noopener">spring-boot</a></strong> ：Spring Boot可以轻松创建独立的生产级基于Spring的应用程序,内置 web 服务器让你可以像运行普通 Java 程序一样运行项目。另外，大部分Spring Boot项目只需要少量的配置即可，这有别于 Spring 的重配置。</li><li><strong><a href="https://github.com/apache/flink" target="_blank" rel="noopener">flink</a></strong> ：Apache Flink 是一个框架和分布式处理引擎，用于在_无边界和有边界_数据流上进行有状态的计算。Flink 能在所有常见集群环境中运行，并能以内存速度和任意规模进行计算。</li><li><strong><a href="https://github.com/alibaba/Sentinel" target="_blank" rel="noopener">Sentinel</a></strong> ：A lightweight powerful flow control component enabling reliability and monitoring for microservices. (轻量级的流量控制、熔断降级 Java 库)。</li><li><strong><a href="https://github.com/apache/dubbo" target="_blank" rel="noopener">dubbo</a></strong> ：Apache Dubbo是一个基于Java的高性能开源RPC框架。</li><li><strong><a href="https://github.com/spring-cloud/spring-cloud-kubernetes" target="_blank" rel="noopener">spring-cloud-kubernetes</a></strong> ： Kubernetes 集成 Spring Cloud Discovery Client, Configuration, etc…。</li><li><strong><a href="https://github.com/apache/skywalking" target="_blank" rel="noopener">skywalking</a></strong> ： 针对分布式系统的应用性能监控，尤其是针对微服务、云原生和面向容器的分布式系统架构。</li></ol><h2 id="软件-系统"><a href="#软件-系统" class="headerlink" title="软件/系统"></a>软件/系统</h2><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><ol><li><strong><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="noopener">elasticsearch</a></strong>：开源，分布式，RESTful搜索引擎。</li><li><strong><a href="https://github.com/openzipkin/zipkin" target="_blank" rel="noopener">zipkin</a></strong> ：Zipkin是一个分布式跟踪系统。它有助于收集解决服务体系结构中的延迟问题所需的时序数据。功能包括该数据的收集和查找。</li><li><strong><a href="https://github.com/ctripcorp/apollo" target="_blank" rel="noopener">apollo</a></strong> ：Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。</li><li><strong><a href="https://github.com/alibaba/canal" target="_blank" rel="noopener">canal</a></strong> :阿里巴巴 MySQL binlog 增量订阅&amp;消费组件。</li><li><strong><a href="https://github.com/alibaba/DataX" target="_blank" rel="noopener">DataX</a></strong> ：DataX 是阿里巴巴集团内被广泛使用的离线数据同步工具/平台，实现包括 MySQL、Oracle、SqlServer、Postgre、HDFS、Hive、ADS、HBase、TableStore(OTS)、MaxCompute(ODPS)、DRDS 等各种异构数据源之间高效的数据同步功能。</li><li><strong><a href="https://github.com/dianping/cat" target="_blank" rel="noopener">cat</a></strong> ： CAT 作为服务端项目基础组件，提供了 Java, C/C , Node.js, Python, Go 等多语言客户端，已经在美团点评的基础架构中间件框架（MVC框架，RPC框架，数据库框架，缓存框架等，消息队列，配置系统等）深度集成，为美团点评各业务线提供系统丰富的性能指标、健康状况、实时告警等。</li><li><strong><a href="https://github.com/wildfirechat/server" target="_blank" rel="noopener">server</a></strong> ： 野火IM是一套跨平台、核心功能开源的即时通讯解决方案。</li><li><strong><a href="https://github.com/analysys/EasyScheduler" target="_blank" rel="noopener">EasyScheduler</a></strong> ： Easy Scheduler是一个分布式工作流任务调度系统，主要解决“复杂任务依赖但无法直接监控任务健康状态”的问题。Easy Scheduler以DAG方式组装任务，可以实时监控任务的运行状态。同时，它支持重试，重新运行等操作… 。</li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li><strong><a href="https://github.com/halo-dev/halo" target="_blank" rel="noopener">halo</a></strong> :Halo 可能是最好的 Java 博客系统。</li></ol><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><ol><li><strong><a href="https://github.com/macrozheng/mall" target="_blank" rel="noopener">mall</a></strong> ：mall 项目是一套电商系统，包括前台商城系统及后台管理系统，基于 SpringBoot MyBatis 实现。</li><li><strong><a href="https://github.com/macrozheng/mall-swarm" target="_blank" rel="noopener">mall-swarm</a></strong> : mall-swarm是一套微服务商城系统，采用了 Spring Cloud Greenwich、Spring Boot 2、MyBatis、Docker、Elasticsearch等核心技术，同时提供了基于Vue的管理后台方便快速搭建系统。</li><li><strong><a href="https://github.com/linlinjava/litemall" target="_blank" rel="noopener">litemall</a></strong> ： 又一个小商城。litemall = Spring Boot后端 Vue管理员前端 微信小程序用户前端 Vue用户移动端。</li><li><strong><a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">vhr</a></strong> ：微人事是一个前后端分离的人力资源管理系统，项目采用SpringBoot Vue开发。</li><li><strong><a href="https://github.com/wuyouzhuguli/FEBS-Shiro" target="_blank" rel="noopener">FEBS-Shiro</a></strong> ：Spring Boot 2.1.3，Shiro1.4.0 &amp; Layui 2.5.4 权限管理系统。</li></ol><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li><strong><a href="https://github.com/google/guava" target="_blank" rel="noopener">guava</a></strong> ：Guava 是一组核心库，其中包括新的集合类型（例如multimap 和 multiset），不可变集合，图形库以及用于并发、I / O、哈希、原始类型、字符串等的实用程序！</li><li><strong><a href="https://github.com/alibaba/p3c" target="_blank" rel="noopener">p3c</a></strong> ：Alibaba Java Coding Guidelines pmd implements and IDE plugin。Eclipse 和 IDEA 上都有该插件，推荐使用！</li><li><strong><a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">arthas</a></strong> ： Arthas 是Alibaba开源的Java诊断工具。</li><li><strong><a href="https://github.com/looly/hutool" target="_blank" rel="noopener">hutool</a></strong> : Hutool是一个Java工具包，也只是一个工具包，它帮助我们简化每一行代码，减少每一个方法，让Java语言也可以“甜甜的”。</li><li><strong><a href="https://github.com/thingsboard/thingsboard" target="_blank" rel="noopener">thingsboard</a></strong> ：开源物联网平台 - 设备管理，数据收集，处理和可视化。</li></ol><h3 id="开源项目推荐"><a href="#开源项目推荐" class="headerlink" title="开源项目推荐"></a>开源项目推荐</h3><p>作者的其他开源项目推荐：</p><ol><li><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">JavaGuide</a>：【Java学习 面试指南】 一份涵盖大部分Java程序员所需要掌握的核心知识。</li><li><a href="https://github.com/Snailclimb/springboot-guide" target="_blank" rel="noopener">springboot-guide</a> : 适合新手入门以及有经验的开发人员查阅的 Spring Boot 教程（业余时间维护中，欢迎一起维护）。</li><li><a href="https://github.com/Snailclimb/programmer-advancement" target="_blank" rel="noopener">programmer-advancement</a> : 我觉得技术人员应该有的一些好习惯！</li><li><a href="https://github.com/Snailclimb/spring-security-jwt-guide" target="_blank" rel="noopener">spring-security-jwt-guide</a> : 从零入门 ！Spring Security With JWT（含权限验证）后端部分代码。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>云游君表情包制作计划</title>
      <link href="/2017/07/10/IDEA%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
      <url>/2017/07/10/IDEA%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h3 id="Grep-Console-控制台输出处理"><a href="#Grep-Console-控制台输出处理" class="headerlink" title="Grep Console:控制台输出处理"></a>Grep Console:控制台输出处理</h3><p>可以说是必备的一个IDEA插件，非常实用！</p><p>这个插件主要的功能有两个：</p><p><strong>1. 自定义设置控制台输出颜色</strong></p><p>我们可以在设置中进行相关的配置:</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-G6HcJ2mP-1588757928734)(<a href="https://user-gold-cdn.xitu.io/2020/5/6/171e959dfa24f7d3?w=3270&amp;h=1244&amp;f=png&amp;s=407612)\]" target="_blank" rel="noopener">https://user-gold-cdn.xitu.io/2020/5/6/171e959dfa24f7d3?w=3270&amp;h=1244&amp;f=png&amp;s=407612)\]</a></p><p>配置完成之后的 log warn 的效果对比图如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC81LzYvMTcxZTk1OWRmYTk0OTQ3MQ?x-oss-process=image/format,png" alt="img" loading="lazy"></p><p><strong>2. 过滤控制台输出</strong></p><p><img src="https://img-blog.csdnimg.cn/20200506174929649.gif" alt="在这里插入图片描述" loading="lazy"></p><h3 id="Rainbow-Brackets-彩虹🌈括号"><a href="#Rainbow-Brackets-彩虹🌈括号" class="headerlink" title="Rainbow Brackets:彩虹🌈括号"></a>Rainbow Brackets:彩虹🌈括号</h3><p>使用各种鲜明的颜色来展示你的括号，效果图如下。可以看出代码层级变得更加清晰了，可以说非常实用友好了！</p><p><img src="https://img-blog.csdnimg.cn/20200506174857496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><h3 id="Save-Actions-优化保存操作"><a href="#Save-Actions-优化保存操作" class="headerlink" title="Save Actions:优化保存操作"></a>Save Actions:优化保存操作</h3><p>真必备插件！可以帮助我们在保存文件的时候：</p><ol><li>优化导入；</li><li>格式化代码；</li><li>执行一些quick fix</li><li>…</li></ol><p>这个插件是支持可配置的，我的配置如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC81LzYvMTcxZTk1OWRmYmYwYTdhMQ?x-oss-process=image/format,png" alt="img" loading="lazy"></p><p>实际使用效果如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC81LzYvMTcxZTk1OWUyZTRhMzlmZg?x-oss-process=image/format,png" alt="img" loading="lazy"></p><h3 id="SequenceDiagram-一键生成时序图"><a href="#SequenceDiagram-一键生成时序图" class="headerlink" title="SequenceDiagram:一键生成时序图"></a>SequenceDiagram:一键生成时序图</h3><p>同样是一个必备的一个IDEA插件，非常实用。我一般用它来生成简单的方法时序图，方便我们阅读代码，特别是在代码的调用层级比较多的时候。</p><p>使用方法很简单，选中方法名（注意不要选类名），然后点击鼠标右键，选择 <strong>Sequence Diagram</strong> 选项即可！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC81LzYvMTcxZTk1OWUzMDljZWIyYg?x-oss-process=image/format,png" alt="img" loading="lazy"></p><p>配置完一些基本的选项比如调用深度之后，我们点击ok即可！在上面这张图中我们已经生成了调用方法之间的时序图。</p><p><img src="https://img-blog.csdnimg.cn/20200506174756860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>时序图生成完成之后，你可以选择导出为图片或者text文件，你还可以通过生成的时序图来定位到相关的代码，这对于我们阅读源码的时候尤其有帮助！</p><h3 id="Maven-Helper-分析Maven项目的相关依赖"><a href="#Maven-Helper-分析Maven项目的相关依赖" class="headerlink" title="Maven Helper:分析Maven项目的相关依赖"></a>Maven Helper:分析Maven项目的相关依赖</h3><p>主要用来分析Maven项目的相关依赖，可以帮助我们解决Maven依赖冲突问题。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC81LzYvMTcxZTk1OWUzMWY5MjIzNw?x-oss-process=image/format,png" alt="img" loading="lazy"></p><p><strong>何为依赖冲突？</strong></p><p>说白了就是你的项目使用的2个jar包引用了同一个依赖h，并且h的版本还不一样,这个时候你的项目就存在两个不同版本的 h。这时Maven会依据依赖路径最短优先原则，来决定使用哪个版本的Jar包，而另一个无用的Jar包则未被使用，这就是所谓的依赖冲突。</p><p>大部分情况下，依赖冲突可能并不会对系统造成什么异常，因为Maven始终选择了一个Jar包来使用。但是，不排除在某些特定条件下，会出现类似找不到类的异常，所以，只要存在依赖冲突，在我看来，最好还是解决掉，不要给系统留下隐患。</p><h3 id="EasyCode-一键帮你生成所需代码"><a href="#EasyCode-一键帮你生成所需代码" class="headerlink" title="EasyCode:一键帮你生成所需代码"></a>EasyCode:一键帮你生成所需代码</h3><p>Easycode 可以直接对数据的表生成entity、controller、service、dao、mapper无需任何编码，简单而强大。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC81LzYvMTcxZTk1OWUzNDE1ZmQ4OQ?x-oss-process=image/format,png" alt="" loading="lazy"></p><p>更多内容可以查看这篇文章：[](<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486205&amp;idx=1&amp;sn=0ff2f87f0d82a1bd9c0c44328ef69435&amp;chksm=cea24536f9d5cc20c6cc7669f0d4167d747fe8b8c05a64546c0162d694aa96044a2862e24b57&amp;token=1862674725&amp;lang=zh_CN&gt;《懒人" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486205&amp;idx=1&amp;sn=0ff2f87f0d82a1bd9c0c44328ef69435&amp;chksm=cea24536f9d5cc20c6cc7669f0d4167d747fe8b8c05a64546c0162d694aa96044a2862e24b57&amp;token=1862674725&amp;lang=zh_CN&gt;《懒人</a> IDEA 插件插件:EasyCode 一键帮你生成所需代码~》</a></p> </p><h3><a name=)CheckStyle:代码格式检查<p>这个插件的作用主要是为了规范代码格式比如说项目中一行代码最长是多少、项目中有没有无用的引用等等。非常实用！</p><p>一般情况下我们会在项目中配置 CheckStyle，并且自定义规则，然后再配置一个Commit 的 Git 钩子，这样我们在Commit代码的时候就会跑一遍 CheckStyle，看看项目代码的格式有问题不。</p><p>这个插件的作用主要是帮助我们定位问题，示例如下：</p><p>我们使用一个自定义的规则，然后运行 CheckStyle ，可以看到这个插件就帮我们找到有一个无用的 import。</p><p><img src="https://img-blog.csdnimg.cn/20200506174726329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><h3 id="SonarLint-帮你优化代码"><a href="#SonarLint-帮你优化代码" class="headerlink" title="SonarLint:帮你优化代码"></a>SonarLint:帮你优化代码</h3><p>SonarLint 帮助你发现代码的错误和漏洞，就像是代码拼写检查器一样，SonarLint 可以实时显示出代码的问题，并提供清晰的修复指导，以便你提交代码之前就可以解决它们。</p><p><img src="https://img-blog.csdnimg.cn/2020050617461291.gif" alt="在这里插入图片描述" loading="lazy"></p><p>并且，很多项目都集成了 SonarQube,SonarLint 可以很方便地与 SonarQube 集成。</p><h3 id="Lombok-帮你简化代码"><a href="#Lombok-帮你简化代码" class="headerlink" title="Lombok:帮你简化代码"></a>Lombok:帮你简化代码</h3><p>之前没有推荐这个插件的原因是觉得已经是人手必备的了。如果你要使用 Lombok 的话，不光是要安装这个插件，你的项目也要引入相关的依赖。</p><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;</code></pre><p>使用 Lombok 能够帮助我们少写很多代码比如 Getter/Setter、Constructor等等。</p><p>关于Lombok的使用，可以查看这篇文章：[](<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485385&amp;idx=2&amp;sn=a7c3fb4485ffd8c019e5541e9b1580cd&amp;chksm=cea24802f9d5c1144eee0da52cfc0cc5e8ee3590990de3bb642df4d4b2a8cd07f12dd54947b9&amp;token=1667678311&amp;lang=zh_CN&gt;《十分钟搞懂Java效率工具Lombok使用与原理》" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485385&amp;idx=2&amp;sn=a7c3fb4485ffd8c019e5541e9b1580cd&amp;chksm=cea24802f9d5c1144eee0da52cfc0cc5e8ee3590990de3bb642df4d4b2a8cd07f12dd54947b9&amp;token=1667678311&amp;lang=zh_CN&gt;《十分钟搞懂Java效率工具Lombok使用与原理》</a></a>。</p> </p><h3><a name=)CodeGlance:代码微型地图<p>提供一个代码的微型地图，当你的类比较多的时候可以帮忙你快速定位到要去的位置。这个插件在我们日常做普通开发的时候用处不大，不过，在你阅读源码的时候还是很有用的，如下图所示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC81LzYvMTcxZTk1OWU2ZTJiNzFmNg?x-oss-process=image/format,png" alt="img" loading="lazy"></p><h3 id="Java-Stream-Debugger-Java8-Stream调试器"><a href="#Java-Stream-Debugger-Java8-Stream调试器" class="headerlink" title="Java Stream Debugger:Java8 Stream调试器"></a>Java Stream Debugger:Java8 Stream调试器</h3><p>Stream API 让你的代码更加优雅，但是有一个缺点是代码更难阅读和理解，没关系，这个插件应该可以帮助到你！</p><p><img src="https://img-blog.csdnimg.cn/20200506174304310.gif" alt="在这里插入图片描述" loading="lazy"></p><h3 id="Git-Commit-Template-使用模板创建commit信息"><a href="#Git-Commit-Template-使用模板创建commit信息" class="headerlink" title="Git Commit Template:使用模板创建commit信息"></a>Git Commit Template:使用模板创建commit信息</h3><p>没有安装这个插件之前，我们使用IDEA提供的Commit功能提交代码是下面这样的：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC81LzYvMTcxZTk1OWU2ZTdkZjg3NQ?x-oss-process=image/format,png" alt="img" loading="lazy"></p><p>使用了这个插件之后是下面这样的，提供了一个commit信息模板的输入框：</p><p><img src="https://img-blog.csdnimg.cn/20200506174133747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>完成之后的效果是这样的：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC81LzYvMTcxZTk1OWVhYTE5YzAwZQ?x-oss-process=image/format,png" alt="img" loading="lazy"></p><h3 id="其他常用插件推荐"><a href="#其他常用插件推荐" class="headerlink" title="其他常用插件推荐"></a>其他常用插件推荐</h3><ol><li><strong>leetcode editor</strong> :提供在线 Leetcode 刷题功能，比较方便我们刷题，不过我试用之后发现有一些小 bug，个人感觉还是直接在网站找题目刷来的痛快一些。</li><li><strong>A Search with Github</strong> ：直接通过 Github搜索相关代码。</li><li><strong>stackoverflow</strong> : 选中相关内容后单击右键即可快速跳转到 stackoverflow 。</li><li><strong>CodeStream</strong> ：让code review变得更加容易。</li><li><strong>Code screenshots</strong> ：代码片段保存为图片。</li><li><strong>activate-power-mode</strong> : 写代码的时候自带动画效果！</li><li><strong>GitToolBox</strong> :Git工具箱</li><li><strong>OK, Gradle!</strong> ：搜索Java库用于Gradle项目</li><li>…</li></ol>]]></content>
      
      
      <categories>
          
          <category> daidai的小画册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daidai </tag>
            
            <tag> 作品 </tag>
            
            <tag> 表情包 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
